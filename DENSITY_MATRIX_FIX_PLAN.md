# Density Matrix Extraction - Fix Plan

**Date:** November 6, 2025
**Status:** ðŸ”§ **IMPLEMENTING FIX**
**Priority:** âš ï¸ **CRITICAL**

---

## Problem Statement

Quantum property calculators (NMR, Raman, dipole) don't properly extract density matrices from quantum solvers (SQD/VQE), resulting in:
- Hardcoded uniform density (0.5) fallbacks
- Constant NMR shifts (-50 ppm)
- Incorrect Raman intensities (1500x error)
- Properties using classical HF density instead of quantum density

---

## Root Cause Analysis

### SQD Solver Issue
**Location:** `kanad/analysis/property_calculator.py:748`

```python
# Current code
result = solver.solve(n_states=n_states + 1)
# TODO: Implement proper density matrix extraction from SQD eigenvector
density_matrix = None  # Will use HF as fallback
```

**Problem:**
- SQD returns eigenvectors in **reduced subspace basis**: shape `(n_states, subspace_dim)`
- Not in full Hilbert space or orbital basis
- Cannot directly compute 1-RDM from subspace eigenvector without basis states
- SQD compresses Hilbert space: 2^n â†’ subspace_dim (e.g., 256 â†’ 10)

**Technical Challenge:**
To get 1-RDM from SQD, we need:
1. Basis states |Ï†áµ¢âŸ© that span the subspace (generated by parametrized circuits)
2. Eigenvector coefficients cáµ¢ in subspace
3. Full state: |ÏˆâŸ© = Î£áµ¢ cáµ¢ |Ï†áµ¢âŸ©
4. Then compute 1-RDM: Ï_{pq} = âŸ¨Ïˆ| aâ€ _p a_q |ÏˆâŸ©

**Current SQD limitation:** Basis states not stored/returned by solver

---

### VQE Solver Issue
**Location:** `kanad/analysis/property_calculator.py:763`

```python
# Current code
result = solver.solve()
# TODO: Implement proper density matrix extraction from VQE state
density_matrix = None  # Will use HF as fallback
```

**Problem:**
- VQE returns optimized parameters and energy
- Final quantum state not extracted/stored
- Cannot compute density matrix without running the circuit again
- Would need to reconstruct state from optimized ansatz

---

### NMR Calculator Fallback
**Location:** `kanad/analysis/nmr_calculator.py:398-401`

```python
except Exception as e:
    logger.warning(f"Could not get SCF density: {e}")
    logger.warning("Using uniform density approximation as fallback")
    n_orbitals = sum(1 if atom.symbol == 'H' else 5 for atom in self.atoms)
    rdm1 = np.eye(2 * n_orbitals) * 0.5  # HARDCODED!
```

**Problem:**
- Falls back to uniform density (0.5 on diagonal)
- Results in constant -50 ppm chemical shifts
- Used when Hamiltonian.solve_scf() fails

---

## Solution Options

### Option 1: Full Quantum Density (Ideal but Complex)
**Approach:** Modify solvers to return full density matrices

**SQD Changes:**
1. Store basis states during subspace generation
2. Return basis states with eigenvectors
3. Implement 1-RDM extraction: `compute_1rdm_from_subspace(eigenvector, basis_states)`

**VQE Changes:**
1. Store final quantum state after optimization
2. Implement 1-RDM extraction from state vector
3. Return density matrix with result

**Effort:** 3-5 days per solver
**Risk:** High (requires major refactoring)

---

### Option 2: Hybrid Quantum-Classical (Practical)
**Approach:** Use classical HF density + quantum energy corrections

**Current Implementation (Partially Working):**
```python
# NMR calculator already does this (lines 424-439)
hf_energy = result.get('hf_energy', ground_state_energy)
correlation_energy = ground_state_energy - hf_energy
correlation_factor = correlation_energy * 10.0  # Empirical scaling
delta_quantum = delta_classical + correlation_factor
```

**Improvements Needed:**
1. Remove hardcoded uniform density fallback
2. Always use Hamiltonian SCF density (available)
3. Improve quantum correction formulas (better scaling)
4. Add correlation-dependent polarizability corrections

**Effort:** 1-2 days
**Risk:** Low (incremental improvement)

---

### Option 3: PySCF Integration (Best Balance)
**Approach:** Use PySCF's density matrix capabilities

**Implementation:**
1. Extract molecular orbitals from Hamiltonian (already available via `hamiltonian.mf`)
2. Use PySCF's FCI/CISD for correlated density if available
3. Fall back to HF density with quantum corrections
4. Properly propagate density through property calculators

**Code Structure:**
```python
def extract_density_from_quantum_solver(solver_result, hamiltonian):
    """Extract best available density matrix from quantum result."""

    # Try to get correlated density from PySCF mean-field object
    if hasattr(hamiltonian, 'mf') and hamiltonian.mf is not None:
        # HF density matrix (available)
        rdm1 = hamiltonian.mf.make_rdm1()

        # Apply quantum correlation corrections
        if 'correlation_energy' in solver_result:
            corr_energy = solver_result['correlation_energy']
            # Scale density based on correlation (preserve trace)
            # ... correction logic ...

        return rdm1

    # Fallback: raise error instead of hardcoded values
    raise ValueError("No density matrix available from Hamiltonian")
```

**Effort:** 2-3 days
**Risk:** Medium (requires understanding PySCF density matrices)

---

## Recommended Solution

**Implement Option 3 (PySCF Integration) + Option 2 (Improved Corrections)**

### Phase 1: Remove Hardcoded Fallbacks (Immediate)
1. âœ… Remove uniform density fallback in NMR calculator (line 401)
2. âœ… Remove `density_matrix = None` in property calculator (lines 749, 764)
3. âœ… Always use Hamiltonian SCF density as base
4. âœ… Fail gracefully with clear error if density unavailable

### Phase 2: Extract HF Density from Hamiltonian (1 day)
1. âœ… Add `get_density_matrix()` method to BaseHamiltonian
2. âœ… Extract `mf.make_rdm1()` from PySCF mean-field object
3. âœ… Update property calculators to use this method
4. âœ… Add tests for density extraction

### Phase 3: Improve Quantum Corrections (1-2 days)
1. âœ… Better NMR shielding corrections (not just linear scaling)
2. âœ… Raman polarizability corrections based on correlation
3. âœ… Dipole moment corrections
4. âœ… Validate improvements against known molecules

### Phase 4: Optional - Full Quantum Density (Future)
1. â³ Modify SQD to store/return basis states
2. â³ Implement 1-RDM extraction from subspace
3. â³ Modify VQE to store final state
4. â³ Benchmark against exact results

---

## Implementation Plan

### Step 1: Add get_density_matrix() to Hamiltonians
**File:** `kanad/core/hamiltonians/covalent_hamiltonian.py`

```python
def get_density_matrix(self) -> np.ndarray:
    """
    Get HF density matrix from PySCF mean-field object.

    Returns:
        rdm1: One-particle density matrix (n_orbitals, n_orbitals)
    """
    if not hasattr(self, 'mf') or self.mf is None:
        raise ValueError("Must run solve_scf() first to generate mean-field object")

    # Extract HF density matrix
    rdm1 = self.mf.make_rdm1()
    return rdm1
```

**Copy to:** IonicHamiltonian, MetallicHamiltonian

---

### Step 2: Update Property Calculator
**File:** `kanad/analysis/property_calculator.py`

```python
# Lines 748-749 (SQD case)
result = solver.solve(n_states=n_states + 1)

# Extract HF density matrix as base
try:
    density_matrix = bond.hamiltonian.get_density_matrix()

    # Apply quantum correlation corrections
    if 'correlation_energy' in result:
        corr_energy = result['correlation_energy']
        hf_energy = result['hf_energy']
        # TODO: Apply density corrections based on correlation
        # For now, use HF density (better than None!)

except Exception as e:
    logger.warning(f"Could not extract density matrix: {e}")
    raise ValueError("Density matrix extraction failed")

state_energy = result['energies'][state_index] if state_index < len(result['energies']) else None
```

**Similarly for VQE case (lines 763-764)**

---

### Step 3: Update NMR Calculator
**File:** `kanad/analysis/nmr_calculator.py`

**Lines 398-401 - REMOVE hardcoded fallback:**
```python
# OLD (REMOVE):
except Exception as e:
    logger.warning(f"Could not get SCF density: {e}")
    logger.warning("Using uniform density approximation as fallback")
    n_orbitals = sum(1 if atom.symbol == 'H' else 5 for atom in self.atoms)
    rdm1 = np.eye(2 * n_orbitals) * 0.5  # HARDCODED!

# NEW (FAIL GRACEFULLY):
except Exception as e:
    logger.error(f"Could not get SCF density: {e}")
    raise ValueError(
        "Quantum NMR requires density matrix from Hamiltonian. "
        "Ensure solve_scf() succeeded before computing NMR."
    ) from e
```

**Lines 424-439 - IMPROVE correlation corrections:**
```python
# Better quantum correction formula
if abs(correlation_energy) > 1e-6:
    # Correlation affects shielding non-linearly
    # Typical effect: 5-20 ppm for small molecules
    # Scale by electron density at nucleus
    corr_factor_ppm = (correlation_energy / hf_energy) * 100.0  # Better scaling
    delta_quantum = delta_classical + corr_factor_ppm
else:
    delta_quantum = delta_classical
```

---

### Step 4: Update Raman Calculator
**File:** `kanad/analysis/raman_calculator.py`

**Lines 166-171 - REPLACE hardcoded formulas:**
```python
# OLD (REMOVE):
alpha_iso = n_electrons * 0.8  # Empirical factor (HARDCODED!)
alpha_parallel = alpha_iso * (1 + 0.5 * R)  # HARDCODED 0.5!

# NEW (USE QUANTUM DENSITY):
# Get polarizability from quantum density matrix
if density_matrix is not None:
    # Compute polarizability from density matrix
    # alpha = Tr(density_matrix @ dipole_matrix)
    alpha_iso = self._compute_polarizability_from_density(density_matrix)

    # Apply correlation corrections
    if 'correlation_energy' in quantum_result:
        corr_factor = 1.0 + (quantum_result['correlation_energy'] / hf_energy) * 0.3
        alpha_iso *= corr_factor
else:
    # Fallback to classical (but not hardcoded!)
    alpha_iso = self._compute_classical_polarizability()
```

---

## Testing Plan

### Phase 1 Tests: Density Extraction
```python
# test_density_extraction.py
def test_covalent_hamiltonian_density():
    """Test that CovalentHamiltonian provides density matrix."""
    bond = BondFactory.create_bond('H', 'H', distance=0.74)
    rdm1, energy = bond.hamiltonian.solve_scf()

    # New method
    rdm1_extracted = bond.hamiltonian.get_density_matrix()

    assert rdm1_extracted is not None
    assert rdm1_extracted.shape[0] == rdm1_extracted.shape[1]
    assert np.allclose(rdm1, rdm1_extracted)  # Should be identical
```

### Phase 2 Tests: Property Calculator
```python
def test_quantum_nmr_with_density():
    """Test that quantum NMR uses real density matrix."""
    molecule = create_h2o()
    nmr = NMRCalculator(molecule)

    result = nmr.compute_chemical_shifts(method='sqd', backend='statevector')

    # Should NOT be constant -50 ppm
    assert not all(abs(s + 50) < 1e-3 for s in result['shifts'])

    # Should vary by atom type
    assert len(set(result['shifts'])) > 1
```

### Phase 3 Tests: Validation
```python
def test_quantum_vs_classical_nmr():
    """Validate quantum NMR improvements."""
    molecule = create_h2o()
    nmr = NMRCalculator(molecule)

    classical = nmr.compute_chemical_shifts(method='HF')
    quantum = nmr.compute_chemical_shifts(method='sqd', backend='statevector')

    # Quantum should be different from classical (correlation effects)
    assert not np.allclose(classical['shifts'], quantum['shifts'], atol=1.0)

    # But not wildly different (within ~20 ppm)
    assert all(abs(q - c) < 20.0 for q, c in zip(quantum['shifts'], classical['shifts']))
```

---

## Timeline

| Phase | Tasks | Effort | Status |
|-------|-------|--------|--------|
| **Phase 1** | Remove hardcoded fallbacks | 4 hours | ðŸ”„ In Progress |
| **Phase 2** | Add get_density_matrix() | 1 day | â³ Pending |
| **Phase 3** | Improve quantum corrections | 1-2 days | â³ Pending |
| **Phase 4** | Validation & testing | 1 day | â³ Pending |
| **Total** | Complete fix | **3-4 days** | |

---

## Success Criteria

âœ… **Phase 1 Complete:**
- No hardcoded uniform density fallbacks
- No `density_matrix = None` assignments
- All calculators use Hamiltonian density

âœ… **Phase 2 Complete:**
- `get_density_matrix()` method works for all Hamiltonians
- Property calculators extract density successfully
- Tests pass for density extraction

âœ… **Phase 3 Complete:**
- NMR shifts vary by atom (not constant -50 ppm)
- Raman intensities within 10x of classical (not 1500x)
- Quantum corrections improve accuracy over HF

âœ… **Phase 4 Complete (Optional):**
- Full quantum density from SQD/VQE
- 1-RDM extraction validated
- Properties match exact CI results

---

## Risk Mitigation

**Risk 1:** Hamiltonian doesn't have mf attribute
- **Mitigation:** Check all Hamiltonian classes have solve_scf()
- **Fallback:** Raise clear error message

**Risk 2:** PySCF density matrix format incompatible
- **Mitigation:** Test with various molecules
- **Fallback:** Convert to numpy array explicitly

**Risk 3:** Quantum corrections don't improve accuracy
- **Mitigation:** Validate against known molecules (H2O, NH3)
- **Fallback:** Keep classical HF density (still better than hardcoded!)

---

**Date:** November 6, 2025
**Status:** ðŸ”§ **READY TO IMPLEMENT**
**Estimated Completion:** November 9-10, 2025
